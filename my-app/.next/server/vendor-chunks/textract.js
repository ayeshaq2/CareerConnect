/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/textract";
exports.ids = ["vendor-chunks/textract"];
exports.modules = {

/***/ "(ssr)/./node_modules/textract/lib/extract.js":
/*!**********************************************!*\
  !*** ./node_modules/textract/lib/extract.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var fs = __webpack_require__(/*! fs */ \"fs\"), path = __webpack_require__(/*! path */ \"path\"), XmlEntities = (__webpack_require__(/*! html-entities */ \"(ssr)/./node_modules/html-entities/index.js\").XmlEntities), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/textract/lib/util.js\"), extractorPath = path.join(__dirname, \"extractors\"), entities = new XmlEntities(), typeExtractors = {}, regexExtractors = [], failedExtractorTypes = {}, totalExtractors = 0, satisfiedExtractors = 0, hasInitialized = false, STRIP_ONLY_SINGLE_LINEBREAKS = /(^|[^\\n])\\n(?!\\n)/g, WHITELIST_PRESERVE_LINEBREAKS = /[^A-Za-z\\x80-\\xFF\\x24\\u20AC\\xA3\\xA5 0-9 \\u2015\\u2116\\u2018\\u2019\\u201C|\\u201D\\u2026 \\uFF0C \\u2013 \\u2014 \\u00C0-\\u1FFF \\u2C00-\\uD7FF \\uFB50–\\uFDFF \\uFE70–\\uFEFF \\uFF01-\\uFFE6 \\.,\\?\"\"!@#\\$%\\^&\\*\\(\\)-_=\\+;:<>\\/\\\\\\|\\}\\{\\[\\]`~'-\\w\\n\\r]*/g // eslint-disable-line max-len\n, WHITELIST_STRIP_LINEBREAKS = /[^A-Za-z\\x80-\\xFF\\x24\\u20AC\\xA3\\xA5 0-9 \\u2015\\u2116\\u2018\\u2019\\u201C|\\u201D\\u2026 \\uFF0C \\u2013 \\u2014 \\u00C0-\\u1FFF \\u2C00-\\uD7FF \\uFB50–\\uFDFF \\uFE70–\\uFEFF \\uFF01-\\uFFE6 \\.,\\?\"\"!@#\\$%\\^&\\*\\(\\)-_=\\+;:<>\\/\\\\\\|\\}\\{\\[\\]`~'-\\w]*/g // eslint-disable-line max-len\n;\nfunction registerExtractor(extractor) {\n    if (extractor.types) {\n        extractor.types.forEach(function(type) {\n            if (typeof type === \"string\") {\n                type = type.toLowerCase();\n                typeExtractors[type] = extractor.extract;\n            } else {\n                if (type instanceof RegExp) {\n                    regexExtractors.push({\n                        reg: type,\n                        extractor: extractor.extract\n                    });\n                }\n            }\n        });\n    }\n}\nfunction registerFailedExtractor(extractor, failedMessage) {\n    if (extractor.types) {\n        extractor.types.forEach(function(type) {\n            failedExtractorTypes[type.toLowerCase()] = failedMessage;\n        });\n    }\n}\nfunction testExtractor(extractor, options) {\n    extractor.test(options, function(passedTest, failedMessage) {\n        satisfiedExtractors++;\n        if (passedTest) {\n            registerExtractor(extractor);\n        } else {\n            registerFailedExtractor(extractor, failedMessage);\n        }\n    });\n}\n// global, all file type, content cleansing\nfunction cleanseText(options, cb) {\n    return function(error, text) {\n        if (!error) {\n            // clean up text\n            text = util.replaceBadCharacters(text);\n            if (options.preserveLineBreaks || options.preserveOnlyMultipleLineBreaks) {\n                if (options.preserveOnlyMultipleLineBreaks) {\n                    text = text.replace(STRIP_ONLY_SINGLE_LINEBREAKS, \"$1 \").trim();\n                }\n                text = text.replace(WHITELIST_PRESERVE_LINEBREAKS, \" \");\n            } else {\n                text = text.replace(WHITELIST_STRIP_LINEBREAKS, \" \");\n            }\n            // multiple spaces, tabs, vertical tabs, non-breaking space]\n            text = text.replace(/ (?! )/g, \"\").replace(/[ \\t\\v\\u00A0]{2,}/g, \" \");\n            text = entities.decode(text);\n        }\n        cb(error, text);\n    };\n}\nfunction initializeExtractors(options) {\n    var extractors;\n    hasInitialized = true;\n    // discover available extractors\n    extractors = fs.readdirSync(extractorPath).map(function(item) {\n        var fullExtractorPath = path.join(extractorPath, item);\n        // get the extractor\n        // eslint-disable-next-line global-require\n        return __webpack_require__(\"(ssr)/./node_modules/textract/lib sync recursive\")(fullExtractorPath);\n    });\n    // perform any binary tests to ensure extractor is possible\n    // given execution environment\n    extractors.forEach(function(extractor) {\n        if (extractor.test) {\n            testExtractor(extractor, options);\n        } else {\n            satisfiedExtractors++;\n            registerExtractor(extractor);\n        }\n    });\n    // need to keep track of how many extractors we have in total\n    totalExtractors = extractors.length;\n}\nfunction findExtractor(type) {\n    var i, iLen = regexExtractors.length, extractor, regexExtractor;\n    type = type.toLowerCase();\n    if (typeExtractors[type]) {\n        extractor = typeExtractors[type];\n    } else {\n        for(i = 0; i < iLen; i++){\n            regexExtractor = regexExtractors[i];\n            if (type.match(regexExtractor.reg)) {\n                extractor = regexExtractor.extractor;\n            }\n        }\n    }\n    return extractor;\n}\nfunction extract(type, filePath, options, cb) {\n    var error, msg, theExtractor;\n    if (!hasInitialized) {\n        initializeExtractors(options);\n    }\n    // registration of extractors complete?\n    if (totalExtractors === satisfiedExtractors) {\n        theExtractor = findExtractor(type);\n        if (theExtractor) {\n            cb = cleanseText(options, cb);\n            theExtractor(filePath, options, cb);\n        } else {\n            // cannot extract this file type\n            msg = \"Error for type: [[ \" + type + \" ]], file: [[ \" + filePath + \" ]]\";\n            // update error message if type is supported but just not configured/installed properly\n            if (failedExtractorTypes[type]) {\n                msg += \", extractor for type exists, but failed to initialize.\" + \" Message: \" + failedExtractorTypes[type];\n            }\n            error = new Error(msg);\n            error.typeNotFound = true;\n            cb(error, null);\n        }\n    } else {\n        // async registration has not wrapped up\n        // try again later\n        setTimeout(function() {\n            extract(type, filePath, options, cb);\n        }, 100);\n    }\n}\nmodule.exports = extract;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGV4dHJhY3QvbGliL2V4dHJhY3QuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsS0FBS0MsbUJBQU9BLENBQUUsaUJBQ2RDLE9BQU9ELG1CQUFPQSxDQUFFLHFCQUNoQkUsY0FBY0YscUdBQXNDLEVBQ3BERyxPQUFPSCxtQkFBT0EsQ0FBRSw0REFDaEJJLGdCQUFnQkgsS0FBS0ksSUFBSSxDQUFFQyxXQUFXLGVBQ3RDQyxXQUFXLElBQUlMLGVBQ2ZNLGlCQUFpQixDQUFDLEdBQ2xCQyxrQkFBa0IsRUFBRSxFQUNwQkMsdUJBQXVCLENBQUMsR0FDeEJDLGtCQUFrQixHQUNsQkMsc0JBQXNCLEdBQ3RCQyxpQkFBaUIsT0FDakJDLCtCQUErQixzQkFDL0JDLGdDQUFnQyw0T0FBNk8sOEJBQThCO0VBQzNTQyw2QkFBNkIsd09BQXlPLDhCQUE4Qjs7QUFHeFMsU0FBU0Msa0JBQW1CQyxTQUFTO0lBQ25DLElBQUtBLFVBQVVDLEtBQUssRUFBRztRQUNyQkQsVUFBVUMsS0FBSyxDQUFDQyxPQUFPLENBQUUsU0FBVUMsSUFBSTtZQUNyQyxJQUFLLE9BQU9BLFNBQVMsVUFBVztnQkFDOUJBLE9BQU9BLEtBQUtDLFdBQVc7Z0JBQ3ZCZCxjQUFjLENBQUNhLEtBQUssR0FBR0gsVUFBVUssT0FBTztZQUMxQyxPQUFPO2dCQUNMLElBQUtGLGdCQUFnQkcsUUFBUztvQkFDNUJmLGdCQUFnQmdCLElBQUksQ0FBQzt3QkFBRUMsS0FBS0w7d0JBQU1ILFdBQVdBLFVBQVVLLE9BQU87b0JBQUM7Z0JBQ2pFO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxTQUFTSSx3QkFBeUJULFNBQVMsRUFBRVUsYUFBYTtJQUN4RCxJQUFLVixVQUFVQyxLQUFLLEVBQUc7UUFDckJELFVBQVVDLEtBQUssQ0FBQ0MsT0FBTyxDQUFFLFNBQVVDLElBQUk7WUFDckNYLG9CQUFvQixDQUFDVyxLQUFLQyxXQUFXLEdBQUcsR0FBR007UUFDN0M7SUFDRjtBQUNGO0FBRUEs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LHVGQUF1RjtZQUN2RixJQUFLN0Msb0JBQW9CLENBQUNXLEtBQUssRUFBRztnQkFDaENtQyxPQUFPLDJEQUNMLGVBQWU5QyxvQkFBb0IsQ0FBQ1csS0FBSztZQUM3QztZQUVBYyxRQUFRLElBQUl1QixNQUFPRjtZQUNuQnJCLE1BQU13QixZQUFZLEdBQUc7WUFDckJ6QixHQUFJQyxPQUFPO1FBQ2I7SUFDRixPQUFPO1FBQ0wsd0NBQXdDO1FBQ3hDLGtCQUFrQjtRQUNsQnlCLFdBQVk7WUFDVnJDLFFBQVNGLE1BQU1rQyxVQUFVekIsU0FBU0k7UUFDcEMsR0FBRztJQUNMO0FBQ0Y7QUFFQTJCLE9BQU9DLE9BQU8sR0FBR3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3RleHRyYWN0L2xpYi9leHRyYWN0LmpzP2QyYWQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGZzID0gcmVxdWlyZSggJ2ZzJyApXG4gICwgcGF0aCA9IHJlcXVpcmUoICdwYXRoJyApXG4gICwgWG1sRW50aXRpZXMgPSByZXF1aXJlKCAnaHRtbC1lbnRpdGllcycgKS5YbWxFbnRpdGllc1xuICAsIHV0aWwgPSByZXF1aXJlKCAnLi91dGlsJyApXG4gICwgZXh0cmFjdG9yUGF0aCA9IHBhdGguam9pbiggX19kaXJuYW1lLCAnZXh0cmFjdG9ycycgKVxuICAsIGVudGl0aWVzID0gbmV3IFhtbEVudGl0aWVzKClcbiAgLCB0eXBlRXh0cmFjdG9ycyA9IHt9XG4gICwgcmVnZXhFeHRyYWN0b3JzID0gW11cbiAgLCBmYWlsZWRFeHRyYWN0b3JUeXBlcyA9IHt9XG4gICwgdG90YWxFeHRyYWN0b3JzID0gMFxuICAsIHNhdGlzZmllZEV4dHJhY3RvcnMgPSAwXG4gICwgaGFzSW5pdGlhbGl6ZWQgPSBmYWxzZVxuICAsIFNUUklQX09OTFlfU0lOR0xFX0xJTkVCUkVBS1MgPSAvKF58W15cXG5dKVxcbig/IVxcbikvZ1xuICAsIFdISVRFTElTVF9QUkVTRVJWRV9MSU5FQlJFQUtTID0gL1teQS1aYS16XFx4ODAtXFx4RkZcXHgyNFxcdTIwQUNcXHhBM1xceEE1IDAtOSBcXHUyMDE1XFx1MjExNlxcdTIwMThcXHUyMDE5XFx1MjAxQ3xcXHUyMDFEXFx1MjAyNiBcXHVGRjBDIFxcdTIwMTMgXFx1MjAxNCBcXHUwMEMwLVxcdTFGRkYgXFx1MkMwMC1cXHVEN0ZGIFxcdUZCNTDigJNcXHVGREZGIFxcdUZFNzDigJNcXHVGRUZGIFxcdUZGMDEtXFx1RkZFNiBcXC4sXFw/XCJcIiFAI1xcJCVcXF4mXFwqXFwoXFwpLV89XFwrOzo8PlxcL1xcXFxcXHxcXH1cXHtcXFtcXF1gfictXFx3XFxuXFxyXSovZyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtbGVuXG4gICwgV0hJVEVMSVNUX1NUUklQX0xJTkVCUkVBS1MgPSAvW15BLVphLXpcXHg4MC1cXHhGRlxceDI0XFx1MjBBQ1xceEEzXFx4QTUgMC05IFxcdTIwMTVcXHUyMTE2XFx1MjAxOFxcdTIwMTlcXHUyMDFDfFxcdTIwMURcXHUyMDI2IFxcdUZGMEMgXFx1MjAxMyBcXHUyMDE0IFxcdTAwQzAtXFx1MUZGRiBcXHUyQzAwLVxcdUQ3RkYgXFx1RkI1MOKAk1xcdUZERkYgXFx1RkU3MOKAk1xcdUZFRkYgXFx1RkYwMS1cXHVGRkU2IFxcLixcXD9cIlwiIUAjXFwkJVxcXiZcXCpcXChcXCktXz1cXCs7Ojw+XFwvXFxcXFxcfFxcfVxce1xcW1xcXWB+Jy1cXHddKi9nICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cbiAgO1xuXG5mdW5jdGlvbiByZWdpc3RlckV4dHJhY3RvciggZXh0cmFjdG9yICkge1xuICBpZiAoIGV4dHJhY3Rvci50eXBlcyApIHtcbiAgICBleHRyYWN0b3IudHlwZXMuZm9yRWFjaCggZnVuY3Rpb24oIHR5cGUgKSB7XG4gICAgICBpZiAoIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdHlwZUV4dHJhY3RvcnNbdHlwZV0gPSBleHRyYWN0b3IuZXh0cmFjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICggdHlwZSBpbnN0YW5jZW9mIFJlZ0V4cCApIHtcbiAgICAgICAgICByZWdleEV4dHJhY3RvcnMucHVzaCh7IHJlZzogdHlwZSwgZXh0cmFjdG9yOiBleHRyYWN0b3IuZXh0cmFjdCB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyRmFpbGVkRXh0cmFjdG9yKCBleHRyYWN0b3IsIGZhaWxlZE1lc3NhZ2UgKSB7XG4gIGlmICggZXh0cmFjdG9yLnR5cGVzICkge1xuICAgIGV4dHJhY3Rvci50eXBlcy5mb3JFYWNoKCBmdW5jdGlvbiggdHlwZSApIHtcbiAgICAgIGZhaWxlZEV4dHJhY3RvclR5cGVzW3R5cGUudG9Mb3dlckNhc2UoKV0gPSBmYWlsZWRNZXNzYWdlO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RFeHRyYWN0b3IoIGV4dHJhY3Rvciwgb3B0aW9ucyApIHtcbiAgZXh0cmFjdG9yLnRlc3QoIG9wdGlvbnMsIGZ1bmN0aW9uKCBwYXNzZWRUZXN0LCBmYWlsZWRNZXNzYWdlICkge1xuICAgIHNhdGlzZmllZEV4dHJhY3RvcnMrKztcbiAgICBpZiAoIHBhc3NlZFRlc3QgKSB7XG4gICAgICByZWdpc3RlckV4dHJhY3RvciggZXh0cmFjdG9yICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZ2lzdGVyRmFpbGVkRXh0cmFjdG9yKCBleHRyYWN0b3IsIGZhaWxlZE1lc3NhZ2UgKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBnbG9iYWwsIGFsbCBmaWxlIHR5cGUsIGNvbnRlbnQgY2xlYW5zaW5nXG5mdW5jdGlvbiBjbGVhbnNlVGV4dCggb3B0aW9ucywgY2IgKSB7XG4gIHJldHVybiBmdW5jdGlvbiggZXJyb3IsIHRleHQgKSB7XG4gICAgaWYgKCAhZXJyb3IgKSB7XG4gICAgICAvLyBjbGVhbiB1cCB0ZXh0XG4gICAgICB0ZXh0ID0gdXRpbC5yZXBsYWNlQmFkQ2hhcmFjdGVycyggdGV4dCApO1xuXG4gICAgICBpZiAoIG9wdGlvbnMucHJlc2VydmVMaW5lQnJlYWtzIHx8IG9wdGlvbnMucHJlc2VydmVPbmx5TXVsdGlwbGVMaW5lQnJlYWtzICkge1xuICAgICAgICBpZiAoIG9wdGlvbnMucHJlc2VydmVPbmx5TXVsdGlwbGVMaW5lQnJlYWtzICkge1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoIFNUUklQX09OTFlfU0lOR0xFX0xJTkVCUkVBS1MsICckMSAnICkudHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoIFdISVRFTElTVF9QUkVTRVJWRV9MSU5FQlJFQUtTLCAnICcgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoIFdISVRFTElTVF9TVFJJUF9MSU5FQlJFQUtTLCAnICcgKTtcbiAgICAgIH1cblxuICAgICAgLy8gbXVsdGlwbGUgc3BhY2VzLCB0YWJzLCB2ZXJ0aWNhbCB0YWJzLCBub24tYnJlYWtpbmcgc3BhY2VdXG4gICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKCAvICg/ISApL2csICcnIClcbiAgICAgICAgLnJlcGxhY2UoIC9bIFxcdFxcdlxcdTAwQTBdezIsfS9nLCAnICcgKTtcblxuICAgICAgdGV4dCA9IGVudGl0aWVzLmRlY29kZSggdGV4dCApO1xuICAgIH1cbiAgICBjYiggZXJyb3IsIHRleHQgKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZUV4dHJhY3RvcnMoIG9wdGlvbnMgKSB7XG4gIHZhciBleHRyYWN0b3JzO1xuXG4gIGhhc0luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAvLyBkaXNjb3ZlciBhdmFpbGFibGUgZXh0cmFjdG9yc1xuICBleHRyYWN0b3JzID0gZnMucmVhZGRpclN5bmMoIGV4dHJhY3RvclBhdGggKS5tYXAoIGZ1bmN0aW9uKCBpdGVtICkge1xuICAgIHZhciBmdWxsRXh0cmFjdG9yUGF0aCA9IHBhdGguam9pbiggZXh0cmFjdG9yUGF0aCwgaXRlbSApO1xuICAgIC8vIGdldCB0aGUgZXh0cmFjdG9yXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdsb2JhbC1yZXF1aXJlXG4gICAgcmV0dXJuIHJlcXVpcmUoIGZ1bGxFeHRyYWN0b3JQYXRoICk7XG4gIH0pO1xuXG4gIC8vIHBlcmZvcm0gYW55IGJpbmFyeSB0ZXN0cyB0byBlbnN1cmUgZXh0cmFjdG9yIGlzIHBvc3NpYmxlXG4gIC8vIGdpdmVuIGV4ZWN1dGlvbiBlbnZpcm9ubWVudFxuICBleHRyYWN0b3JzLmZvckVhY2goIGZ1bmN0aW9uKCBleHRyYWN0b3IgKSB7XG4gICAgaWYgKCBleHRyYWN0b3IudGVzdCApIHtcbiAgICAgIHRlc3RFeHRyYWN0b3IoIGV4dHJhY3Rvciwgb3B0aW9ucyApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzYXRpc2ZpZWRFeHRyYWN0b3JzKys7XG4gICAgICByZWdpc3RlckV4dHJhY3RvciggZXh0cmFjdG9yICk7XG4gICAgfVxuICB9KTtcblxuICAvLyBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgZXh0cmFjdG9ycyB3ZSBoYXZlIGluIHRvdGFsXG4gIHRvdGFsRXh0cmFjdG9ycyA9IGV4dHJhY3RvcnMubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBmaW5kRXh0cmFjdG9yKCB0eXBlICkge1xuICB2YXIgaVxuICAgICwgaUxlbiA9IHJlZ2V4RXh0cmFjdG9ycy5sZW5ndGhcbiAgICAsIGV4dHJhY3RvclxuICAgICwgcmVnZXhFeHRyYWN0b3JcbiAgICA7XG5cbiAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCB0eXBlRXh0cmFjdG9yc1t0eXBlXSApIHtcbiAgICBleHRyYWN0b3IgPSB0eXBlRXh0cmFjdG9yc1t0eXBlXTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKCBpID0gMDsgaSA8IGlMZW47IGkrKyApIHtcbiAgICAgIHJlZ2V4RXh0cmFjdG9yID0gcmVnZXhFeHRyYWN0b3JzW2ldO1xuICAgICAgaWYgKCB0eXBlLm1hdGNoKCByZWdleEV4dHJhY3Rvci5yZWcgKSApIHtcbiAgICAgICAgZXh0cmFjdG9yID0gcmVnZXhFeHRyYWN0b3IuZXh0cmFjdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZXh0cmFjdG9yO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0KCB0eXBlLCBmaWxlUGF0aCwgb3B0aW9ucywgY2IgKSB7XG4gIHZhciBlcnJvciwgbXNnLCB0aGVFeHRyYWN0b3I7XG5cbiAgaWYgKCAhaGFzSW5pdGlhbGl6ZWQgKSB7XG4gICAgaW5pdGlhbGl6ZUV4dHJhY3RvcnMoIG9wdGlvbnMgKTtcbiAgfVxuXG4gIC8vIHJlZ2lzdHJhdGlvbiBvZiBleHRyYWN0b3JzIGNvbXBsZXRlP1xuICBpZiAoIHRvdGFsRXh0cmFjdG9ycyA9PT0gc2F0aXNmaWVkRXh0cmFjdG9ycyApIHtcbiAgICB0aGVFeHRyYWN0b3IgPSBmaW5kRXh0cmFjdG9yKCB0eXBlICk7XG5cbiAgICBpZiAoIHRoZUV4dHJhY3RvciApIHtcbiAgICAgIGNiID0gY2xlYW5zZVRleHQoIG9wdGlvbnMsIGNiICk7XG4gICAgICB0aGVFeHRyYWN0b3IoIGZpbGVQYXRoLCBvcHRpb25zLCBjYiApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjYW5ub3QgZXh0cmFjdCB0aGlzIGZpbGUgdHlwZVxuICAgICAgbXNnID0gJ0Vycm9yIGZvciB0eXBlOiBbWyAnICsgdHlwZSArICcgXV0sIGZpbGU6IFtbICcgKyBmaWxlUGF0aCArICcgXV0nO1xuXG4gICAgICAvLyB1cGRhdGUgZXJyb3IgbWVzc2FnZSBpZiB0eXBlIGlzIHN1cHBvcnRlZCBidXQganVzdCBub3QgY29uZmlndXJlZC9pbnN0YWxsZWQgcHJvcGVybHlcbiAgICAgIGlmICggZmFpbGVkRXh0cmFjdG9yVHlwZXNbdHlwZV0gKSB7XG4gICAgICAgIG1zZyArPSAnLCBleHRyYWN0b3IgZm9yIHR5cGUgZXhpc3RzLCBidXQgZmFpbGVkIHRvIGluaXRpYWxpemUuJyArXG4gICAgICAgICAgJyBNZXNzYWdlOiAnICsgZmFpbGVkRXh0cmFjdG9yVHlwZXNbdHlwZV07XG4gICAgICB9XG5cbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCBtc2cgKTtcbiAgICAgIGVycm9yLnR5cGVOb3RGb3VuZCA9IHRydWU7XG4gICAgICBjYiggZXJyb3IsIG51bGwgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gYXN5bmMgcmVnaXN0cmF0aW9uIGhhcyBub3Qgd3JhcHBlZCB1cFxuICAgIC8vIHRyeSBhZ2FpbiBsYXRlclxuICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgZXh0cmFjdCggdHlwZSwgZmlsZVBhdGgsIG9wdGlvbnMsIGNiICk7XG4gICAgfSwgMTAwICk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHRyYWN0O1xuIl0sIm5hbWVzIjpbImZzIiwicmVxdWlyZSIsInBhdGgiLCJYbWxFbnRpdGllcyIsInV0aWwiLCJleHRyYWN0b3JQYXRoIiwiam9pbiIsIl9fZGlybmFtZSIsImVudGl0aWVzIiwidHlwZUV4dHJhY3RvcnMiLCJyZWdleEV4dHJhY3RvcnMiLCJmYWlsZWRFeHRyYWN0b3JUeXBlcyIsInRvdGFsRXh0cmFjdG9ycyIsInNhdGlzZmllZEV4dHJhY3RvcnMiLCJoYXNJbml0aWFsaXplZCIsIlNUUklQX09OTFlfU0lOR0xFX0xJTkVCUkVBS1MiLCJXSElURUxJU1RfUFJFU0VSVkVfTElORUJSRUFLUyIsIldISVRFTElTVF9TVFJJUF9MSU5FQlJFQUtTIiwicmVnaXN0ZXJFeHRyYWN0b3IiLCJleHRyYWN0b3IiLCJ0eXBlcyIsImZvckVhY2giLCJ0eXBlIiwidG9Mb3dlckNhc2UiLCJleHRyYWN0IiwiUmVnRXhwIiwicHVzaCIsInJlZyIsInJlZ2lzdGVyRmFpbGVkRXh0cmFjdG9yIiwiZmFpbGVkTWVzc2FnZSIsInRlc3RFeHRyYWN0b3IiLCJvcHRpb25zIiwidGVzdCIsInBhc3NlZFRlc3QiLCJjbGVhbnNlVGV4dCIsImNiIiwiZXJyb3IiLCJ0ZXh0IiwicmVwbGFjZUJhZENoYXJhY3RlcnMiLCJwcmVzZXJ2ZUxpbmVCcmVha3MiLCJwcmVzZXJ2ZU9ubHlNdWx0aXBsZUxpbmVCcmVha3MiLCJyZXBsYWNlIiwidHJpbSIsImRlY29kZSIsImluaXRpYWxpemVFeHRyYWN0b3JzIiwiZXh0cmFjdG9ycyIsInJlYWRkaXJTeW5jIiwibWFwIiwiaXRlbSIsImZ1bGxFeHRyYWN0b3JQYXRoIiwibGVuZ3RoIiwiZmluZEV4dHJhY3RvciIsImkiLCJpTGVuIiwicmVnZXhFeHRyYWN0b3IiLCJtYXRjaCIsImZpbGVQYXRoIiwibXNnIiwidGhlRXh0cmFjdG9yIiwiRXJyb3IiLCJ0eXBlTm90Rm91bmQiLCJzZXRUaW1lb3V0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/textract/lib/extract.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/textract/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/textract/lib/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var fs = __webpack_require__(/*! fs */ \"fs\"), path = __webpack_require__(/*! path */ \"path\"), mime = __webpack_require__(/*! mime */ \"(ssr)/./node_modules/mime/index.js\"), extract = __webpack_require__(/*! ./extract */ \"(ssr)/./node_modules/textract/lib/extract.js\"), os = __webpack_require__(/*! os */ \"os\"), got = __webpack_require__(/*! got */ \"(ssr)/./node_modules/got/index.js\"), tmpDir = os.tmpdir();\nfunction _genRandom() {\n    return Math.floor(Math.random() * 100000000000 + 1);\n}\nfunction _extractWithType(type, filePath, options, cb) {\n    fs.exists(filePath, function(exists) {\n        if (exists) {\n            extract(type, filePath, options, cb);\n        } else {\n            cb(new Error(\"File at path [[ \" + filePath + \" ]] does not exist.\"), null);\n        }\n    });\n}\nfunction _returnArgsError(_args) {\n    var args = Array.prototype.slice.call(_args), callback;\n    args.forEach(function(parm) {\n        if (parm && typeof parm === \"function\") {\n            callback = parm;\n        }\n    });\n    if (callback) {\n        callback(new Error(\"Incorrect parameters passed to textract.\"), null);\n    } else {\n        // eslint-disable-next-line no-console\n        console.error(\"textract could not find a callback function to execute.\");\n    }\n}\nfunction _writeBufferToDisk(buff, cb) {\n    var fullPath = path.join(tmpDir, \"textract_file_\" + _genRandom());\n    fs.open(fullPath, \"w\", function(err, fd) {\n        if (err) {\n            throw new Error(\"error opening temp file: \" + err);\n        } else {\n            fs.write(fd, buff, 0, buff.length, null, function(err2) {\n                if (err2) {\n                    throw new Error(\"error writing temp file: \" + err2);\n                } else {\n                    fs.close(fd, function() {\n                        cb(fullPath);\n                    });\n                }\n            });\n        }\n    });\n}\nfunction fromFileWithMimeAndPath(type, filePath, options, cb) {\n    var called = false;\n    if (typeof type === \"string\" && typeof filePath === \"string\") {\n        if (typeof cb === \"function\" && typeof options === \"object\") {\n            // (mimeType, filePath, options, callback)\n            _extractWithType(type, filePath, options, cb);\n            called = true;\n        } else if (typeof options === \"function\" && cb === undefined) {\n            // (mimeType, filePath, callback)\n            _extractWithType(type, filePath, {}, options);\n            called = true;\n        }\n    }\n    if (!called) {\n        _returnArgsError(arguments);\n    }\n}\nfunction fromFileWithPath(filePath, options, cb) {\n    var type;\n    if (typeof filePath === \"string\" && (typeof options === \"function\" || typeof cb === \"function\")) {\n        type = options && options.typeOverride || mime.getType(filePath);\n        fromFileWithMimeAndPath(type, filePath, options, cb);\n    } else {\n        _returnArgsError(arguments);\n    }\n}\n// eslint-disable-next-line no-unused-vars\nfunction fromBufferWithMime(type, bufferContent, options, cb, withPath) {\n    if (typeof type === \"string\" && bufferContent && bufferContent instanceof Buffer && (typeof options === \"function\" || typeof cb === \"function\")) {\n        _writeBufferToDisk(bufferContent, function(newPath) {\n            fromFileWithMimeAndPath(type, newPath, options, cb);\n        });\n    } else {\n        _returnArgsError(arguments);\n    }\n}\nfunction fromBufferWithName(filePath, bufferContent, options, cb) {\n    var type;\n    if (typeof filePath === \"string\") {\n        type = mime.getType(filePath);\n        fromBufferWithMime(type, bufferContent, options, cb, true);\n    } else {\n        _returnArgsError(arguments);\n    }\n}\nfunction fromUrl(url, options, cb) {\n    var urlNoQueryParams, extname, filePath, fullFilePath, file, href, callbackCalled;\n    // allow url to be either a string or to be a\n    // Node URL Object: https://nodejs.org/api/url.html\n    href = typeof url === \"string\" ? url : url.href;\n    if (href) {\n        options = options || {};\n        urlNoQueryParams = href.split(\"?\")[0];\n        extname = path.extname(urlNoQueryParams);\n        filePath = _genRandom() + extname;\n        fullFilePath = path.join(tmpDir, filePath);\n        file = fs.createWriteStream(fullFilePath);\n        file.on(\"finish\", function() {\n            if (!callbackCalled) {\n                fromFileWithPath(fullFilePath, options, cb);\n            }\n        });\n        got.stream(url).on(\"response\", function(response) {\n            // allows for overriding by the developer or automatically\n            // populating based on server response.\n            if (!options.typeOverride) {\n                options.typeOverride = response.headers[\"content-type\"].split(/;/)[0];\n            }\n        }).on(\"error\", function(error) {\n            var _cb = typeof options === \"function\" ? options : cb;\n            callbackCalled = true;\n            _cb(error);\n        }).pipe(file);\n    } else {\n        _returnArgsError(arguments);\n    }\n}\nmodule.exports = {\n    fromFileWithPath: fromFileWithPath,\n    fromFileWithMimeAndPath: fromFileWithMimeAndPath,\n    fromBufferWithName: fromBufferWithName,\n    fromBufferWithMime: fromBufferWithMime,\n    fromUrl: fromUrl\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGV4dHJhY3QvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLEtBQUtDLG1CQUFPQSxDQUFFLGlCQUNkQyxPQUFPRCxtQkFBT0EsQ0FBRSxxQkFDaEJFLE9BQU9GLG1CQUFPQSxDQUFFLG1EQUNoQkcsVUFBVUgsbUJBQU9BLENBQUUsa0VBQ25CSSxLQUFLSixtQkFBT0EsQ0FBRSxpQkFDZEssTUFBTUwsbUJBQU9BLENBQUUsaURBQ2ZNLFNBQVNGLEdBQUdHLE1BQU07QUFHdEIsU0FBU0M7SUFDUCxPQUFPQyxLQUFLQyxLQUFLLENBQUUsS0FBT0MsTUFBTSxLQUFLLGVBQWlCO0FBQ3hEO0FBRUEsU0FBU0MsaUJBQWtCQyxJQUFJLEVBQUVDLFFBQVEsRUFBRUMsT0FBTyxFQUFFQyxFQUFFO0lBQ3BEakIsR0FBR2tCLE1BQU0sQ0FBRUgsVUFBVSxTQUFVRyxNQUFNO1FBQ25DLElBQUtBLFFBQVM7WUFDWmQsUUFBU1UsTUFBTUMsVUFBVUMsU0FBU0M7UUFDcEMsT0FBTztZQUNMQSxHQUFJLElBQUlFLE1BQU8scUJBQXFCSixXQUFXLHdCQUF5QjtRQUMxRTtJQUNGO0FBQ0Y7QUFFQSxTQUFTSyxpQkFBa0JDLEtBQUs7SUFDOUIsSUFBSUMsT0FBT0MsTUFBTUMsU0FBUyxDQUFDQyxLQUFLLENBQUNDLElBQUksQ0FBRUwsUUFDbkNNO0lBR0pMLEtBQUtNLE9BQU8sQ0FBRSxTQUFVQyxJQUFJO1FBQzFCLElBQUtBLFFBQVEsT0FBT0EsU0FBUyxZQUFhO1lBQ3hDRixXQUFXRTtRQUNiO0lBQ0Y7SUFFQSxJQUFLRixVQUFXO1FBQ2RBLFNBQVUsSUFBSVIsTUFBTyw2Q0FBOEM7SUFDckUsT0FBTztRQUNMLHNDQUFzQztRQUN0Q1csUUFBUUMsS0FBSyxDQUFFO0lBQ2pCO0FBQ0Y7QUFFQSxTQUFTQyxtQkFBb0JDLElBQUksRUFBRWhCLEVBQUU7SUFDbkMsSUFBSWlCLFdBQVdoQyxLQUFLaUMsSUFBSSxDQUFFNUIsUUFBUSxt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LElBQUksQ0FBRTVCLFFBQVFRO1FBQ2xDOEMsT0FBTzdELEdBQUdpRSxpQkFBaUIsQ0FBRUw7UUFDN0JDLEtBQUtLLEVBQUUsQ0FBRSxVQUFVO1lBQ2pCLElBQUssQ0FBQ0gsZ0JBQWlCO2dCQUNyQmhCLGlCQUFrQmEsY0FBYzVDLFNBQVNDO1lBQzNDO1FBQ0Y7UUFFQVgsSUFBSTZELE1BQU0sQ0FBRVYsS0FDVFMsRUFBRSxDQUFFLFlBQVksU0FBVUUsUUFBUTtZQUNqQywwREFBMEQ7WUFDMUQsdUNBQXVDO1lBQ3ZDLElBQUssQ0FBQ3BELFFBQVFnQyxZQUFZLEVBQUc7Z0JBQzNCaEMsUUFBUWdDLFlBQVksR0FBR29CLFNBQVNDLE9BQU8sQ0FBQyxlQUFlLENBQUNMLEtBQUssQ0FBRSxJQUFLLENBQUMsRUFBRTtZQUN6RTtRQUNGLEdBQ0NFLEVBQUUsQ0FBRSxTQUFTLFNBQVVuQyxLQUFLO1lBQzNCLElBQUl1QyxNQUFNLE9BQVN0RCxZQUFZLGFBQWVBLFVBQVVDO1lBQ3hEOEMsaUJBQWlCO1lBQ2pCTyxJQUFLdkM7UUFDUCxHQUNDd0MsSUFBSSxDQUFFVjtJQUNYLE9BQU87UUFDTHpDLGlCQUFrQjBCO0lBQ3BCO0FBQ0Y7QUFFQTBCLE9BQU9DLE9BQU8sR0FBRztJQUNmMUIsa0JBQWtCQTtJQUNsQkoseUJBQXlCQTtJQUN6Qlksb0JBQW9CQTtJQUNwQkwsb0JBQW9CQTtJQUNwQk0sU0FBU0E7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy90ZXh0cmFjdC9saWIvaW5kZXguanM/YjQ4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZnMgPSByZXF1aXJlKCAnZnMnIClcbiAgLCBwYXRoID0gcmVxdWlyZSggJ3BhdGgnIClcbiAgLCBtaW1lID0gcmVxdWlyZSggJ21pbWUnIClcbiAgLCBleHRyYWN0ID0gcmVxdWlyZSggJy4vZXh0cmFjdCcgKVxuICAsIG9zID0gcmVxdWlyZSggJ29zJyApXG4gICwgZ290ID0gcmVxdWlyZSggJ2dvdCcgKVxuICAsIHRtcERpciA9IG9zLnRtcGRpcigpXG4gIDtcblxuZnVuY3Rpb24gX2dlblJhbmRvbSgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoICggTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDAwMCApICsgMSApO1xufVxuXG5mdW5jdGlvbiBfZXh0cmFjdFdpdGhUeXBlKCB0eXBlLCBmaWxlUGF0aCwgb3B0aW9ucywgY2IgKSB7XG4gIGZzLmV4aXN0cyggZmlsZVBhdGgsIGZ1bmN0aW9uKCBleGlzdHMgKSB7XG4gICAgaWYgKCBleGlzdHMgKSB7XG4gICAgICBleHRyYWN0KCB0eXBlLCBmaWxlUGF0aCwgb3B0aW9ucywgY2IgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2IoIG5ldyBFcnJvciggJ0ZpbGUgYXQgcGF0aCBbWyAnICsgZmlsZVBhdGggKyAnIF1dIGRvZXMgbm90IGV4aXN0LicgKSwgbnVsbCApO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIF9yZXR1cm5BcmdzRXJyb3IoIF9hcmdzICkge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBfYXJncyApXG4gICAgLCBjYWxsYmFja1xuICAgIDtcblxuICBhcmdzLmZvckVhY2goIGZ1bmN0aW9uKCBwYXJtICkge1xuICAgIGlmICggcGFybSAmJiB0eXBlb2YgcGFybSA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgIGNhbGxiYWNrID0gcGFybTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmICggY2FsbGJhY2sgKSB7XG4gICAgY2FsbGJhY2soIG5ldyBFcnJvciggJ0luY29ycmVjdCBwYXJhbWV0ZXJzIHBhc3NlZCB0byB0ZXh0cmFjdC4nICksIG51bGwgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUuZXJyb3IoICd0ZXh0cmFjdCBjb3VsZCBub3QgZmluZCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUuJyApO1xuICB9XG59XG5cbmZ1bmN0aW9uIF93cml0ZUJ1ZmZlclRvRGlzayggYnVmZiwgY2IgKSB7XG4gIHZhciBmdWxsUGF0aCA9IHBhdGguam9pbiggdG1wRGlyLCAndGV4dHJhY3RfZmlsZV8nICsgX2dlblJhbmRvbSgpICk7XG5cbiAgZnMub3BlbiggZnVsbFBhdGgsICd3JywgZnVuY3Rpb24oIGVyciwgZmQgKSB7XG4gICAgaWYgKCBlcnIgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoICdlcnJvciBvcGVuaW5nIHRlbXAgZmlsZTogJyArIGVyciApO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcy53cml0ZSggZmQsIGJ1ZmYsIDAsIGJ1ZmYubGVuZ3RoLCBudWxsLCBmdW5jdGlvbiggZXJyMiApIHtcbiAgICAgICAgaWYgKCBlcnIyICkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvciggJ2Vycm9yIHdyaXRpbmcgdGVtcCBmaWxlOiAnICsgZXJyMiApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZzLmNsb3NlKCBmZCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjYiggZnVsbFBhdGggKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZnJvbUZpbGVXaXRoTWltZUFuZFBhdGgoIHR5cGUsIGZpbGVQYXRoLCBvcHRpb25zLCBjYiApIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuXG4gIGlmICggdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBmaWxlUGF0aCA9PT0gJ3N0cmluZycgKSB7XG4gICAgaWYgKCB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICkge1xuICAgICAgLy8gKG1pbWVUeXBlLCBmaWxlUGF0aCwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgICBfZXh0cmFjdFdpdGhUeXBlKCB0eXBlLCBmaWxlUGF0aCwgb3B0aW9ucywgY2IgKTtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICggdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgJiYgY2IgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIC8vIChtaW1lVHlwZSwgZmlsZVBhdGgsIGNhbGxiYWNrKVxuICAgICAgX2V4dHJhY3RXaXRoVHlwZSggdHlwZSwgZmlsZVBhdGgsIHt9LCBvcHRpb25zICk7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICggIWNhbGxlZCApIHtcbiAgICBfcmV0dXJuQXJnc0Vycm9yKCBhcmd1bWVudHMgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmcm9tRmlsZVdpdGhQYXRoKCBmaWxlUGF0aCwgb3B0aW9ucywgY2IgKSB7XG4gIHZhciB0eXBlO1xuICBpZiAoIHR5cGVvZiBmaWxlUGF0aCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAoIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJyApICkge1xuICAgIHR5cGUgPSAoIG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlT3ZlcnJpZGUgKSB8fCBtaW1lLmdldFR5cGUoIGZpbGVQYXRoICk7XG4gICAgZnJvbUZpbGVXaXRoTWltZUFuZFBhdGgoIHR5cGUsIGZpbGVQYXRoLCBvcHRpb25zLCBjYiApO1xuICB9IGVsc2Uge1xuICAgIF9yZXR1cm5BcmdzRXJyb3IoIGFyZ3VtZW50cyApO1xuICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuZnVuY3Rpb24gZnJvbUJ1ZmZlcldpdGhNaW1lKCB0eXBlLCBidWZmZXJDb250ZW50LCBvcHRpb25zLCBjYiwgd2l0aFBhdGggKSB7XG4gIGlmICggdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgYnVmZmVyQ29udGVudCAmJlxuICAgICAgIGJ1ZmZlckNvbnRlbnQgaW5zdGFuY2VvZiBCdWZmZXIgJiZcbiAgICAgICAoIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJyApICkge1xuICAgIF93cml0ZUJ1ZmZlclRvRGlzayggYnVmZmVyQ29udGVudCwgZnVuY3Rpb24oIG5ld1BhdGggKSB7XG4gICAgICBmcm9tRmlsZVdpdGhNaW1lQW5kUGF0aCggdHlwZSwgbmV3UGF0aCwgb3B0aW9ucywgY2IgKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBfcmV0dXJuQXJnc0Vycm9yKCBhcmd1bWVudHMgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmcm9tQnVmZmVyV2l0aE5hbWUoIGZpbGVQYXRoLCBidWZmZXJDb250ZW50LCBvcHRpb25zLCBjYiApIHtcbiAgdmFyIHR5cGU7XG4gIGlmICggdHlwZW9mIGZpbGVQYXRoID09PSAnc3RyaW5nJyApIHtcbiAgICB0eXBlID0gbWltZS5nZXRUeXBlKCBmaWxlUGF0aCApO1xuICAgIGZyb21CdWZmZXJXaXRoTWltZSggdHlwZSwgYnVmZmVyQ29udGVudCwgb3B0aW9ucywgY2IsIHRydWUgKTtcbiAgfSBlbHNlIHtcbiAgICBfcmV0dXJuQXJnc0Vycm9yKCBhcmd1bWVudHMgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmcm9tVXJsKCB1cmwsIG9wdGlvbnMsIGNiICkge1xuICB2YXIgdXJsTm9RdWVyeVBhcmFtcywgZXh0bmFtZSwgZmlsZVBhdGgsIGZ1bGxGaWxlUGF0aCwgZmlsZSwgaHJlZiwgY2FsbGJhY2tDYWxsZWQ7XG5cbiAgLy8gYWxsb3cgdXJsIHRvIGJlIGVpdGhlciBhIHN0cmluZyBvciB0byBiZSBhXG4gIC8vIE5vZGUgVVJMIE9iamVjdDogaHR0cHM6Ly9ub2RlanMub3JnL2FwaS91cmwuaHRtbFxuICBocmVmID0gKCB0eXBlb2YgdXJsID09PSAnc3RyaW5nJyApID8gdXJsIDogdXJsLmhyZWY7XG5cbiAgaWYgKCBocmVmICkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHVybE5vUXVlcnlQYXJhbXMgPSBocmVmLnNwbGl0KCAnPycgKVswXTtcbiAgICBleHRuYW1lID0gcGF0aC5leHRuYW1lKCB1cmxOb1F1ZXJ5UGFyYW1zICk7XG4gICAgZmlsZVBhdGggPSBfZ2VuUmFuZG9tKCkgKyBleHRuYW1lO1xuICAgIGZ1bGxGaWxlUGF0aCA9IHBhdGguam9pbiggdG1wRGlyLCBmaWxlUGF0aCApO1xuICAgIGZpbGUgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbSggZnVsbEZpbGVQYXRoICk7XG4gICAgZmlsZS5vbiggJ2ZpbmlzaCcsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCAhY2FsbGJhY2tDYWxsZWQgKSB7XG4gICAgICAgIGZyb21GaWxlV2l0aFBhdGgoIGZ1bGxGaWxlUGF0aCwgb3B0aW9ucywgY2IgKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGdvdC5zdHJlYW0oIHVybCApXG4gICAgICAub24oICdyZXNwb25zZScsIGZ1bmN0aW9uKCByZXNwb25zZSApIHtcbiAgICAgICAgLy8gYWxsb3dzIGZvciBvdmVycmlkaW5nIGJ5IHRoZSBkZXZlbG9wZXIgb3IgYXV0b21hdGljYWxseVxuICAgICAgICAvLyBwb3B1bGF0aW5nIGJhc2VkIG9uIHNlcnZlciByZXNwb25zZS5cbiAgICAgICAgaWYgKCAhb3B0aW9ucy50eXBlT3ZlcnJpZGUgKSB7XG4gICAgICAgICAgb3B0aW9ucy50eXBlT3ZlcnJpZGUgPSByZXNwb25zZS5oZWFkZXJzWydjb250ZW50LXR5cGUnXS5zcGxpdCggLzsvIClbMF07XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAub24oICdlcnJvcicsIGZ1bmN0aW9uKCBlcnJvciApIHtcbiAgICAgICAgdmFyIF9jYiA9ICggdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgKSA/IG9wdGlvbnMgOiBjYjtcbiAgICAgICAgY2FsbGJhY2tDYWxsZWQgPSB0cnVlO1xuICAgICAgICBfY2IoIGVycm9yICk7XG4gICAgICB9KVxuICAgICAgLnBpcGUoIGZpbGUgKTtcbiAgfSBlbHNlIHtcbiAgICBfcmV0dXJuQXJnc0Vycm9yKCBhcmd1bWVudHMgKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZnJvbUZpbGVXaXRoUGF0aDogZnJvbUZpbGVXaXRoUGF0aCxcbiAgZnJvbUZpbGVXaXRoTWltZUFuZFBhdGg6IGZyb21GaWxlV2l0aE1pbWVBbmRQYXRoLFxuICBmcm9tQnVmZmVyV2l0aE5hbWU6IGZyb21CdWZmZXJXaXRoTmFtZSxcbiAgZnJvbUJ1ZmZlcldpdGhNaW1lOiBmcm9tQnVmZmVyV2l0aE1pbWUsXG4gIGZyb21Vcmw6IGZyb21Vcmxcbn07XG4iXSwibmFtZXMiOlsiZnMiLCJyZXF1aXJlIiwicGF0aCIsIm1pbWUiLCJleHRyYWN0Iiwib3MiLCJnb3QiLCJ0bXBEaXIiLCJ0bXBkaXIiLCJfZ2VuUmFuZG9tIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiX2V4dHJhY3RXaXRoVHlwZSIsInR5cGUiLCJmaWxlUGF0aCIsIm9wdGlvbnMiLCJjYiIsImV4aXN0cyIsIkVycm9yIiwiX3JldHVybkFyZ3NFcnJvciIsIl9hcmdzIiwiYXJncyIsIkFycmF5IiwicHJvdG90eXBlIiwic2xpY2UiLCJjYWxsIiwiY2FsbGJhY2siLCJmb3JFYWNoIiwicGFybSIsImNvbnNvbGUiLCJlcnJvciIsIl93cml0ZUJ1ZmZlclRvRGlzayIsImJ1ZmYiLCJmdWxsUGF0aCIsImpvaW4iLCJvcGVuIiwiZXJyIiwiZmQiLCJ3cml0ZSIsImxlbmd0aCIsImVycjIiLCJjbG9zZSIsImZyb21GaWxlV2l0aE1pbWVBbmRQYXRoIiwiY2FsbGVkIiwidW5kZWZpbmVkIiwiYXJndW1lbnRzIiwiZnJvbUZpbGVXaXRoUGF0aCIsInR5cGVPdmVycmlkZSIsImdldFR5cGUiLCJmcm9tQnVmZmVyV2l0aE1pbWUiLCJidWZmZXJDb250ZW50Iiwid2l0aFBhdGgiLCJCdWZmZXIiLCJuZXdQYXRoIiwiZnJvbUJ1ZmZlcldpdGhOYW1lIiwiZnJvbVVybCIsInVybCIsInVybE5vUXVlcnlQYXJhbXMiLCJleHRuYW1lIiwiZnVsbEZpbGVQYXRoIiwiZmlsZSIsImhyZWYiLCJjYWxsYmFja0NhbGxlZCIsInNwbGl0IiwiY3JlYXRlV3JpdGVTdHJlYW0iLCJvbiIsInN0cmVhbSIsInJlc3BvbnNlIiwiaGVhZGVycyIsIl9jYiIsInBpcGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/textract/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/textract/lib/util.js":
/*!*******************************************!*\
  !*** ./node_modules/textract/lib/util.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var exec = (__webpack_require__(/*! child_process */ \"child_process\").exec), path = __webpack_require__(/*! path */ \"path\"), fs = __webpack_require__(/*! fs */ \"fs\"), os = __webpack_require__(/*! os */ \"os\"), outDir = path.join(os.tmpdir(), \"textract\"), replacements = [\n    [\n        /[\\u201C|\\u201D|]|â€œ|â€/g,\n        '\"'\n    ],\n    [\n        /[\\u2018|\\u2019]|â€™|â€˜]/g,\n        \"'\"\n    ],\n    [\n        /â€¦/g,\n        \"…\"\n    ],\n    [\n        /â€“|â€”/g,\n        \"–\"\n    ] // long hyphen\n], rLen = replacements.length;\n// Up front creation of tmp dir\nif (!fs.existsSync(outDir)) {\n    fs.mkdirSync(outDir);\n}\n// replace nasty quotes with simple ones\nfunction replaceBadCharacters(text) {\n    var i, repl;\n    for(i = 0; i < rLen; i++){\n        repl = replacements[i];\n        text = text.replace(repl[0], repl[1]);\n    }\n    return text;\n}\nfunction yauzlError(err, cb) {\n    var msg = err.message;\n    if (msg === \"end of central directory record signature not found\") {\n        msg = \"File not correctly recognized as zip file, \" + msg;\n    }\n    cb(new Error(msg), null);\n}\nfunction createExecOptions(type, options) {\n    var execOptions = {};\n    if (options[type] && options[type].exec) {\n        execOptions = options[type].exec;\n    } else {\n        if (options.exec) {\n            execOptions = options.exec;\n        }\n    }\n    return execOptions;\n}\nfunction unzipCheck(type, cb) {\n    exec(\"unzip\", function(error /* , stdout, stderr */ ) {\n        if (error) {\n            // eslint-disable-next-line no-console\n            console.error(\"textract: 'unzip' does not appear to be installed, \" + \"so textract will be unable to extract \" + type + \".\");\n        }\n        cb(error === null);\n    });\n}\nfunction getTextFromZipFile(zipfile, entry, cb) {\n    zipfile.openReadStream(entry, function(err, readStream) {\n        var text = \"\", error = \"\";\n        if (err) {\n            cb(err, null);\n            return;\n        }\n        readStream.on(\"data\", function(chunk) {\n            text += chunk;\n        });\n        readStream.on(\"end\", function() {\n            if (error.length > 0) {\n                cb(error, null);\n            } else {\n                cb(null, text);\n            }\n        });\n        readStream.on(\"error\", function(_err) {\n            error += _err;\n        });\n    });\n}\n/**\n * 1) builds an exec command using provided `genCommand` callback\n * 2) runs that command against an input file path\n *   resulting in an output file\n * 3) reads that output file in\n * 4) cleans the output file up\n * 5) executes a callback with the contents of the file\n *\n * @param {string} label Name for the extractor, e.g. `Tesseract`\n * @param {string} filePath path to file to be extractor\n * @param {object} options extractor options as provided\n *   via user configuration\n * @param {object} execOptions execution options passed to\n *   `exec` commmand as provided via user configuration\n * @param {function} genCommand function used to generate\n *   the command to be executed\n * @param {string} cb callback that is passed error/text\n *\n */ function runExecIntoFile(label, filePath, options, execOptions, genCommand, cb) {\n    // escape the file paths\n    var fileTempOutPath = path.join(outDir, path.basename(filePath, path.extname(filePath))), escapedFilePath = filePath.replace(/\\s/g, \"\\\\ \"), escapedFileTempOutPath = fileTempOutPath.replace(/\\s/g, \"\\\\ \"), cmd = genCommand(options, escapedFilePath, escapedFileTempOutPath);\n    exec(cmd, execOptions, function(error /* , stdout, stderr */ ) {\n        if (error !== null) {\n            error = new Error(\"Error extracting [[ \" + path.basename(filePath) + \" ]], exec error: \" + error.message);\n            cb(error, null);\n            return;\n        }\n        fs.exists(fileTempOutPath + \".txt\", function(exists) {\n            if (exists) {\n                fs.readFile(fileTempOutPath + \".txt\", \"utf8\", function(error2, text) {\n                    if (error2) {\n                        error2 = new Error(\"Error reading\" + label + \" output at [[ \" + fileTempOutPath + \" ]], error: \" + error2.message);\n                        cb(error2, null);\n                    } else {\n                        fs.unlink(fileTempOutPath + \".txt\", function(error3) {\n                            if (error3) {\n                                error3 = new Error(\"Error, \" + label + \" , cleaning up temp file [[ \" + fileTempOutPath + \" ]], error: \" + error3.message);\n                                cb(error3, null);\n                            } else {\n                                cb(null, text.toString());\n                            }\n                        });\n                    }\n                });\n            } else {\n                error = new Error(\"Error reading \" + label + \" output at [[ \" + fileTempOutPath + \" ]], file does not exist\");\n                cb(error, null);\n            }\n        });\n    });\n}\nmodule.exports = {\n    createExecOptions: createExecOptions,\n    unzipCheck: unzipCheck,\n    getTextFromZipFile: getTextFromZipFile,\n    yauzlError: yauzlError,\n    runExecIntoFile: runExecIntoFile,\n    replaceBadCharacters: replaceBadCharacters\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGV4dHJhY3QvbGliL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsT0FBT0MsZ0VBQStCLEVBQ3RDQyxPQUFPRCxtQkFBT0EsQ0FBRSxxQkFDaEJFLEtBQUtGLG1CQUFPQSxDQUFFLGlCQUNkRyxLQUFLSCxtQkFBT0EsQ0FBRSxpQkFDZEksU0FBU0gsS0FBS0ksSUFBSSxDQUFFRixHQUFHRyxNQUFNLElBQUksYUFDakNDLGVBQWU7SUFDZjtRQUFDO1FBQTRCO0tBQUk7SUFDakM7UUFBQztRQUE2QjtLQUFLO0lBQ25DO1FBQUM7UUFBUTtLQUFJO0lBQ2I7UUFBQztRQUFZO0tBQUksQ0FBQyxjQUFjO0NBQ2pDLEVBQ0NDLE9BQU9ELGFBQWFFLE1BQU07QUFHOUIsK0JBQStCO0FBQy9CLElBQUssQ0FBQ1AsR0FBR1EsVUFBVSxDQUFFTixTQUFXO0lBQzlCRixHQUFHUyxTQUFTLENBQUVQO0FBQ2hCO0FBRUEsd0NBQXdDO0FBQ3hDLFNBQVNRLHFCQUFzQkMsSUFBSTtJQUNqQyxJQUFJQyxHQUFHQztJQUNQLElBQU1ELElBQUksR0FBR0EsSUFBSU4sTUFBTU0sSUFBTTtRQUMzQkMsT0FBT1IsWUFBWSxDQUFDTyxFQUFFO1FBQ3RCRCxPQUFPQSxLQUFLRyxPQUFPLENBQUVELElBQUksQ0FBQyxFQUFFLEVBQUVBLElBQUksQ0FBQyxFQUFFO0lBQ3ZDO0lBQ0EsT0FBT0Y7QUFDVDtBQUVBLFNBQVNJLFdBQVlDLEdBQUcsRUFBRUMsRUFBRTtJQUMxQixJQUFJQyxNQUFNRixJQUFJRyxPQUFPO0lBQ3JCLElBQUtELFFBQVEsdURBQXdEO1FBQ25FQSxNQUFNLGdEQUFnREE7SUFDeEQ7SUFDQUQsR0FBSSxJQUFJRyxNQUFPRixNQUFPO0FBQ3hCO0FBRUEsU0FBU0csa0JBQW1CQyxJQUFJLEVBQUVDLE9BQU87SUFDdkMsSUFBSUMsY0FBYyxDQUFDO0lBQ25CLElBQUtELE9BQU8sQ0FBQ0QsS0FBSyxJQUFJQyxPQUFPLENBQUNELEtBQUssQ0FBQ3pCLElBQUksRUFBRztRQUN6QzJCLGNBQWNELE9BQU8sQ0FBQ0QsS0FBSyxDQUFDekIsSUFBSTtJQUNsQyxPQUFPO1FBQ0wsSUFBSzBCLFFBQVExQixJQUFJLEVBQUc7WUFDbEIyQixjQUFjRCxRQUFRMUIsSUFBSTtRQUM1QjtJQUNGO0lBQ0EsT0FBTzJCO0FBQ1Q7QUFFQSxTQUFTQyxXQUFZSCxJQUFJLEVBQUVMLEVBQUU7SUFDM0JwQixLQUFNLFNBQ0osU0FBVTZCLE1BQU0sb0JBQW9CLEdBQXJCO1FBQ2IsSUFBS0EsT0FBUTtZQUNYLHNDQUFzQztZQUN0Q0MsUUFBUUQsS0FBSyxDQUFFLHdEQUNiLDJDQUEyQ0osT0FBTztRQUN0RDtRQUNBTCxHQUFJUyxVQUFVO0lBQ2hCO0FBRUo7QUFFQSxTQUFTRSxtQkFBb0JDLE9BQU8sRUFBRUMsS0FBSyxFQUFFYixFQUFFO0lBQzdDWSxRQUFRRSxjQUFjLENBQUVELE9BQU8sU0FBVWQsR0FBRyxFQUFFZ0IsVUFBVTtRQUN0RCxJQUFJckIsT0FBTyxJQUNQZSxRQUFRO1FBR1osSUFBS1YsS0FBTTtZQUNUQyxHQUFJRCxLQUFLO1lBQ1Q7UUFDRjtRQUVBZ0IsV0FBV0MsRUFBRSxDQUFFLFFBQVEsU0FBVUMsS0FBSztZQUNwQ3ZCLFFBQVF1QjtRQUNWO1FBQ0FGLFdBQVdDLEVBQUUsQ0FBRSxPQUFPO1lBQ3BCLElBQUtQLE1BQU1uQixNQUFNLEdBQUcsR0FBSTtnQkFDdEJVLEdBQUlTLE9BQU87WUFDYixPQUFPO2dCQUNMVCxHQUFJLE1BQU1OO1lBQ1o7UUFDRjtRQUNBcUIsV0FBV0MsRUFBRSxDQUFFLFNBQVMsU0FBVUUsSUFBSTtZQUNwQ1QsU0FBU1M7UUFDWDtJQUNGO0FBQ0Y7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0JDLEdBQ0QsU0FBU0MsZ0JBQWlCQyxLQUFLLEVBQUVDLFFBQVEsRUFBRWYsT0FBTyxFQUFFQyxXQUFXLEVBQUVlLFVBQVUsRUFBRXRCLEVBQUU7SUFDN0Usd0JBQXdCO0lBQ3hCLElBQUl1QixrQkFBa0J6QyxLQUFLSSxJQUFJLENBQUVELFFBQVFILEtBQUswQyxRQUFRLENBQUVILFVBQVV2QyxLQUFLMkMsT0FBTyxDQUFFSixhQUM1RUssa0JBQWtCTCxTQUFTeEIsT0FBTyxDQUFFLE9BQU8sUUFDM0M4Qix5QkFBeUJKLGdCQUFnQjFCLE9BQU8sQ0FBRSxPQUFPLFFBQ3pEK0IsTUFBTU4sV0FBWWhCLFNBQVNvQixpQkFBaUJDO0lBR2hEL0MsS0FBTWdELEtBQUtyQixhQUNULFNBQVVFLE1BQU0sb0JBQW9CLEdBQXJCO1FBQ2IsSUFBS0EsVUFBVSxNQUFPO1lBQ3BCQSxRQUFRLElBQUlOLE1BQU8seUJBQ2pCckIsS0FBSzBDLFFBQVEsQ0FBRUgsWUFBYSxzQkFBc0JaLE1BQU1QLE9BQU87WUFDakVGLEdBQUlTLE9BQU87WUFDWDtRQUNGO1FBRUExQixHQUFHOEMsTUFBTSxDQUFFTixrQkFBa0IsUUFBUSxTQUFVTSxNQUFNO1lBQ25ELElBQUtBLFFBQVM7Z0JBQ1o5QyxHQUFHK0MsUUFBUSxDQUFFUCxrQkFBa0IsUUFBUSxRQUFRLFNBQVVRLE1BQU0sRUFBRXJDLElBQUk7b0JBQ25FLElBQUtxQyxRQUFTO3dCQUNaQSxTQUFTLElBQUk1QixNQUFPLGtCQUFrQmlCLFFBQ3BDLG1CQUFtQkcsa0JBQWtCLGlCQUFpQlEsT0FBTzdCLE9BQU87d0JBQ3RFRixHQUFJK0IsUUFBUTtvQkFDZCxPQUFPO3dCQUNMaEQsR0FBR2lELE1BQU0sQ0FBRVQsa0JBQWtCLFFBQVEsU0FBVVUsTUFBTTs0QkFDbkQsSUFBS0EsUUFBUztnQ0FDWkEsU0FBUyxJQUFJOUIsTUFBTyxZQUFZaUIsUUFDOUIsaUNBQWlDRyxrQkFDakMsaUJBQWlCVSxPQUFPL0IsT0FBTztnQ0FDakNGLEdBQUlpQyxRQUFROzRCQUNkLE9BQU87Z0NBQ0xqQyxHQUFJLE1BQU1OLEtBQUt3QyxRQUFROzRCQUN6Qjt3QkFDRjtvQkFDRjtnQkFDRjtZQUNGLE9BQU87Z0JBQ0x6QixRQUFRLElBQUlOLE1BQU8sbUJBQW1CaUIsUUFDcEMsbUJBQW1CRyxrQkFBa0I7Z0JBQ3ZDdkIsR0FBSVMsT0FBTztZQUNiO1FBQ0Y7SUFDRjtBQUVKO0FBRUEwQixPQUFPQyxPQUFPLEdBQUc7SUFDZmhDLG1CQUFtQkE7SUFDbkJJLFlBQVlBO0lBQ1pHLG9CQUFvQkE7SUFDcEJiLFlBQVlBO0lBQ1pxQixpQkFBaUJBO0lBQ2pCMUIsc0JBQXNCQTtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy90ZXh0cmFjdC9saWIvdXRpbC5qcz9mMTYwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBleGVjID0gcmVxdWlyZSggJ2NoaWxkX3Byb2Nlc3MnICkuZXhlY1xuICAsIHBhdGggPSByZXF1aXJlKCAncGF0aCcgKVxuICAsIGZzID0gcmVxdWlyZSggJ2ZzJyApXG4gICwgb3MgPSByZXF1aXJlKCAnb3MnIClcbiAgLCBvdXREaXIgPSBwYXRoLmpvaW4oIG9zLnRtcGRpcigpLCAndGV4dHJhY3QnIClcbiAgLCByZXBsYWNlbWVudHMgPSBbXG4gICAgWy9bXFx1MjAxQ3xcXHUyMDFEfF18w6LigqzFk3zDouKCrC9nLCAnXCInXSwgLy8gZmFuY3kgZG91YmxlIHF1b3Rlc1xuICAgIFsvW1xcdTIwMTh8XFx1MjAxOV18w6LigqzihKJ8w6LigqzLnF0vZywgJ1xcJyddLCAvLyBmYW5jeSBzaW5nbGUgcXVvdGVzL2Fwb3N0cm9waGVzXG4gICAgWy/DouKCrMKmL2csICfigKYnXSwgLy8gZWxpcHNlc1xuICAgIFsvw6LigqzigJx8w6LigqzigJ0vZywgJ+KAkyddIC8vIGxvbmcgaHlwaGVuXG4gIF1cbiAgLCByTGVuID0gcmVwbGFjZW1lbnRzLmxlbmd0aFxuICA7XG5cbi8vIFVwIGZyb250IGNyZWF0aW9uIG9mIHRtcCBkaXJcbmlmICggIWZzLmV4aXN0c1N5bmMoIG91dERpciApICkge1xuICBmcy5ta2RpclN5bmMoIG91dERpciApO1xufVxuXG4vLyByZXBsYWNlIG5hc3R5IHF1b3RlcyB3aXRoIHNpbXBsZSBvbmVzXG5mdW5jdGlvbiByZXBsYWNlQmFkQ2hhcmFjdGVycyggdGV4dCApIHtcbiAgdmFyIGksIHJlcGw7XG4gIGZvciAoIGkgPSAwOyBpIDwgckxlbjsgaSsrICkge1xuICAgIHJlcGwgPSByZXBsYWNlbWVudHNbaV07XG4gICAgdGV4dCA9IHRleHQucmVwbGFjZSggcmVwbFswXSwgcmVwbFsxXSApO1xuICB9XG4gIHJldHVybiB0ZXh0O1xufVxuXG5mdW5jdGlvbiB5YXV6bEVycm9yKCBlcnIsIGNiICkge1xuICB2YXIgbXNnID0gZXJyLm1lc3NhZ2U7XG4gIGlmICggbXNnID09PSAnZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IHJlY29yZCBzaWduYXR1cmUgbm90IGZvdW5kJyApIHtcbiAgICBtc2cgPSAnRmlsZSBub3QgY29ycmVjdGx5IHJlY29nbml6ZWQgYXMgemlwIGZpbGUsICcgKyBtc2c7XG4gIH1cbiAgY2IoIG5ldyBFcnJvciggbXNnICksIG51bGwgKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRXhlY09wdGlvbnMoIHR5cGUsIG9wdGlvbnMgKSB7XG4gIHZhciBleGVjT3B0aW9ucyA9IHt9O1xuICBpZiAoIG9wdGlvbnNbdHlwZV0gJiYgb3B0aW9uc1t0eXBlXS5leGVjICkge1xuICAgIGV4ZWNPcHRpb25zID0gb3B0aW9uc1t0eXBlXS5leGVjO1xuICB9IGVsc2Uge1xuICAgIGlmICggb3B0aW9ucy5leGVjICkge1xuICAgICAgZXhlY09wdGlvbnMgPSBvcHRpb25zLmV4ZWM7XG4gICAgfVxuICB9XG4gIHJldHVybiBleGVjT3B0aW9ucztcbn1cblxuZnVuY3Rpb24gdW56aXBDaGVjayggdHlwZSwgY2IgKSB7XG4gIGV4ZWMoICd1bnppcCcsXG4gICAgZnVuY3Rpb24oIGVycm9yIC8qICwgc3Rkb3V0LCBzdGRlcnIgKi8gKSB7XG4gICAgICBpZiAoIGVycm9yICkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmVycm9yKCAndGV4dHJhY3Q6IFxcJ3VuemlwXFwnIGRvZXMgbm90IGFwcGVhciB0byBiZSBpbnN0YWxsZWQsICcgK1xuICAgICAgICAgICdzbyB0ZXh0cmFjdCB3aWxsIGJlIHVuYWJsZSB0byBleHRyYWN0ICcgKyB0eXBlICsgJy4nICk7XG4gICAgICB9XG4gICAgICBjYiggZXJyb3IgPT09IG51bGwgKTtcbiAgICB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldFRleHRGcm9tWmlwRmlsZSggemlwZmlsZSwgZW50cnksIGNiICkge1xuICB6aXBmaWxlLm9wZW5SZWFkU3RyZWFtKCBlbnRyeSwgZnVuY3Rpb24oIGVyciwgcmVhZFN0cmVhbSApIHtcbiAgICB2YXIgdGV4dCA9ICcnXG4gICAgICAsIGVycm9yID0gJydcbiAgICAgIDtcblxuICAgIGlmICggZXJyICkge1xuICAgICAgY2IoIGVyciwgbnVsbCApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlYWRTdHJlYW0ub24oICdkYXRhJywgZnVuY3Rpb24oIGNodW5rICkge1xuICAgICAgdGV4dCArPSBjaHVuaztcbiAgICB9KTtcbiAgICByZWFkU3RyZWFtLm9uKCAnZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIGVycm9yLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgIGNiKCBlcnJvciwgbnVsbCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IoIG51bGwsIHRleHQgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZWFkU3RyZWFtLm9uKCAnZXJyb3InLCBmdW5jdGlvbiggX2VyciApIHtcbiAgICAgIGVycm9yICs9IF9lcnI7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIDEpIGJ1aWxkcyBhbiBleGVjIGNvbW1hbmQgdXNpbmcgcHJvdmlkZWQgYGdlbkNvbW1hbmRgIGNhbGxiYWNrXG4gKiAyKSBydW5zIHRoYXQgY29tbWFuZCBhZ2FpbnN0IGFuIGlucHV0IGZpbGUgcGF0aFxuICogICByZXN1bHRpbmcgaW4gYW4gb3V0cHV0IGZpbGVcbiAqIDMpIHJlYWRzIHRoYXQgb3V0cHV0IGZpbGUgaW5cbiAqIDQpIGNsZWFucyB0aGUgb3V0cHV0IGZpbGUgdXBcbiAqIDUpIGV4ZWN1dGVzIGEgY2FsbGJhY2sgd2l0aCB0aGUgY29udGVudHMgb2YgdGhlIGZpbGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgTmFtZSBmb3IgdGhlIGV4dHJhY3RvciwgZS5nLiBgVGVzc2VyYWN0YFxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVQYXRoIHBhdGggdG8gZmlsZSB0byBiZSBleHRyYWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGV4dHJhY3RvciBvcHRpb25zIGFzIHByb3ZpZGVkXG4gKiAgIHZpYSB1c2VyIGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBleGVjT3B0aW9ucyBleGVjdXRpb24gb3B0aW9ucyBwYXNzZWQgdG9cbiAqICAgYGV4ZWNgIGNvbW1tYW5kIGFzIHByb3ZpZGVkIHZpYSB1c2VyIGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGdlbkNvbW1hbmQgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZVxuICogICB0aGUgY29tbWFuZCB0byBiZSBleGVjdXRlZFxuICogQHBhcmFtIHtzdHJpbmd9IGNiIGNhbGxiYWNrIHRoYXQgaXMgcGFzc2VkIGVycm9yL3RleHRcbiAqXG4gKi9cbmZ1bmN0aW9uIHJ1bkV4ZWNJbnRvRmlsZSggbGFiZWwsIGZpbGVQYXRoLCBvcHRpb25zLCBleGVjT3B0aW9ucywgZ2VuQ29tbWFuZCwgY2IgKSB7XG4gIC8vIGVzY2FwZSB0aGUgZmlsZSBwYXRoc1xuICB2YXIgZmlsZVRlbXBPdXRQYXRoID0gcGF0aC5qb2luKCBvdXREaXIsIHBhdGguYmFzZW5hbWUoIGZpbGVQYXRoLCBwYXRoLmV4dG5hbWUoIGZpbGVQYXRoICkgKSApXG4gICAgLCBlc2NhcGVkRmlsZVBhdGggPSBmaWxlUGF0aC5yZXBsYWNlKCAvXFxzL2csICdcXFxcICcgKVxuICAgICwgZXNjYXBlZEZpbGVUZW1wT3V0UGF0aCA9IGZpbGVUZW1wT3V0UGF0aC5yZXBsYWNlKCAvXFxzL2csICdcXFxcICcgKVxuICAgICwgY21kID0gZ2VuQ29tbWFuZCggb3B0aW9ucywgZXNjYXBlZEZpbGVQYXRoLCBlc2NhcGVkRmlsZVRlbXBPdXRQYXRoIClcbiAgICA7XG5cbiAgZXhlYyggY21kLCBleGVjT3B0aW9ucyxcbiAgICBmdW5jdGlvbiggZXJyb3IgLyogLCBzdGRvdXQsIHN0ZGVyciAqLyApIHtcbiAgICAgIGlmICggZXJyb3IgIT09IG51bGwgKSB7XG4gICAgICAgIGVycm9yID0gbmV3IEVycm9yKCAnRXJyb3IgZXh0cmFjdGluZyBbWyAnICtcbiAgICAgICAgICBwYXRoLmJhc2VuYW1lKCBmaWxlUGF0aCApICsgJyBdXSwgZXhlYyBlcnJvcjogJyArIGVycm9yLm1lc3NhZ2UgKTtcbiAgICAgICAgY2IoIGVycm9yLCBudWxsICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZnMuZXhpc3RzKCBmaWxlVGVtcE91dFBhdGggKyAnLnR4dCcsIGZ1bmN0aW9uKCBleGlzdHMgKSB7XG4gICAgICAgIGlmICggZXhpc3RzICkge1xuICAgICAgICAgIGZzLnJlYWRGaWxlKCBmaWxlVGVtcE91dFBhdGggKyAnLnR4dCcsICd1dGY4JywgZnVuY3Rpb24oIGVycm9yMiwgdGV4dCApIHtcbiAgICAgICAgICAgIGlmICggZXJyb3IyICkge1xuICAgICAgICAgICAgICBlcnJvcjIgPSBuZXcgRXJyb3IoICdFcnJvciByZWFkaW5nJyArIGxhYmVsICtcbiAgICAgICAgICAgICAgICAnIG91dHB1dCBhdCBbWyAnICsgZmlsZVRlbXBPdXRQYXRoICsgJyBdXSwgZXJyb3I6ICcgKyBlcnJvcjIubWVzc2FnZSApO1xuICAgICAgICAgICAgICBjYiggZXJyb3IyLCBudWxsICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmcy51bmxpbmsoIGZpbGVUZW1wT3V0UGF0aCArICcudHh0JywgZnVuY3Rpb24oIGVycm9yMyApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGVycm9yMyApIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yMyA9IG5ldyBFcnJvciggJ0Vycm9yLCAnICsgbGFiZWwgK1xuICAgICAgICAgICAgICAgICAgICAnICwgY2xlYW5pbmcgdXAgdGVtcCBmaWxlIFtbICcgKyBmaWxlVGVtcE91dFBhdGggK1xuICAgICAgICAgICAgICAgICAgICAnIF1dLCBlcnJvcjogJyArIGVycm9yMy5tZXNzYWdlICk7XG4gICAgICAgICAgICAgICAgICBjYiggZXJyb3IzLCBudWxsICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNiKCBudWxsLCB0ZXh0LnRvU3RyaW5nKCkgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCAnRXJyb3IgcmVhZGluZyAnICsgbGFiZWwgK1xuICAgICAgICAgICAgJyBvdXRwdXQgYXQgW1sgJyArIGZpbGVUZW1wT3V0UGF0aCArICcgXV0sIGZpbGUgZG9lcyBub3QgZXhpc3QnICk7XG4gICAgICAgICAgY2IoIGVycm9yLCBudWxsICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZUV4ZWNPcHRpb25zOiBjcmVhdGVFeGVjT3B0aW9ucyxcbiAgdW56aXBDaGVjazogdW56aXBDaGVjayxcbiAgZ2V0VGV4dEZyb21aaXBGaWxlOiBnZXRUZXh0RnJvbVppcEZpbGUsXG4gIHlhdXpsRXJyb3I6IHlhdXpsRXJyb3IsXG4gIHJ1bkV4ZWNJbnRvRmlsZTogcnVuRXhlY0ludG9GaWxlLFxuICByZXBsYWNlQmFkQ2hhcmFjdGVyczogcmVwbGFjZUJhZENoYXJhY3RlcnNcbn07XG4iXSwibmFtZXMiOlsiZXhlYyIsInJlcXVpcmUiLCJwYXRoIiwiZnMiLCJvcyIsIm91dERpciIsImpvaW4iLCJ0bXBkaXIiLCJyZXBsYWNlbWVudHMiLCJyTGVuIiwibGVuZ3RoIiwiZXhpc3RzU3luYyIsIm1rZGlyU3luYyIsInJlcGxhY2VCYWRDaGFyYWN0ZXJzIiwidGV4dCIsImkiLCJyZXBsIiwicmVwbGFjZSIsInlhdXpsRXJyb3IiLCJlcnIiLCJjYiIsIm1zZyIsIm1lc3NhZ2UiLCJFcnJvciIsImNyZWF0ZUV4ZWNPcHRpb25zIiwidHlwZSIsIm9wdGlvbnMiLCJleGVjT3B0aW9ucyIsInVuemlwQ2hlY2siLCJlcnJvciIsImNvbnNvbGUiLCJnZXRUZXh0RnJvbVppcEZpbGUiLCJ6aXBmaWxlIiwiZW50cnkiLCJvcGVuUmVhZFN0cmVhbSIsInJlYWRTdHJlYW0iLCJvbiIsImNodW5rIiwiX2VyciIsInJ1bkV4ZWNJbnRvRmlsZSIsImxhYmVsIiwiZmlsZVBhdGgiLCJnZW5Db21tYW5kIiwiZmlsZVRlbXBPdXRQYXRoIiwiYmFzZW5hbWUiLCJleHRuYW1lIiwiZXNjYXBlZEZpbGVQYXRoIiwiZXNjYXBlZEZpbGVUZW1wT3V0UGF0aCIsImNtZCIsImV4aXN0cyIsInJlYWRGaWxlIiwiZXJyb3IyIiwidW5saW5rIiwiZXJyb3IzIiwidG9TdHJpbmciLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/textract/lib/util.js\n");

/***/ })

};
;